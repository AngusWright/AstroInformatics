[
  {
    "objectID": "first_shinylive.html",
    "href": "first_shinylive.html",
    "title": "first_shinylive.qmd",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n#|\nlibrary(shiny)\nlibrary(bslib)\n\nvars &lt;- setdiff(names(iris), \"Species\")\n\n# Define UI for app that draws a histogram ----\nui &lt;- page_sidebar(\n  sidebar = sidebar(open = \"open\", \n    selectInput('xcol', 'X Variable', vars),\n    selectInput('ycol', 'Y Variable', vars, selected = vars[[2]]),\n    numericInput('clusters', 'Cluster count', 3, min = 1, max = 9)\n  ),\n  plotOutput(\"plot\", height=\"100%\",width=\"100%\", fill=TRUE)\n)\n\nserver &lt;- function(input, output, session) {\n   selectedData &lt;- reactive({\n      iris[, c(input$xcol, input$ycol)]\n    })\n  \n  clusters &lt;- reactive({\n    kmeans(selectedData(), input$clusters)\n  })\n  \n  output$plot &lt;- renderPlot({\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n      \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n  \n    par(mar = c(4.1, 4.1, 0, 1))\n    magicaxis::magplot(selectedData(),\n         col = clusters()$cluster,\n         pch = 20, cex = 3, side=1:4,labels=c(T,T,F,F), \n         xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n         ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n    points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n#| standalone: true\n#| viewerHeight: 600\n#|\nlibrary(shiny)\nlibrary(bslib)\n\nvars &lt;- setdiff(names(cars), \"Species\")\n\n# Define UI for app that draws a histogram ----\nui &lt;- page_sidebar(\n  sidebar = sidebar(open = \"open\", \n    selectInput('xcol', 'X Variable', vars),\n    selectInput('ycol', 'Y Variable', vars, selected = vars[[2]]),\n    numericInput('clusters', 'Cluster count', 3, min = 1, max = 9)\n  ),\n  plotOutput(\"plot\", height=\"100%\",width=\"100%\", fill=TRUE)\n)\n\nserver &lt;- function(input, output, session) {\n   selectedData &lt;- reactive({\n      cars[, c(input$xcol, input$ycol)]\n    })\n  \n  clusters &lt;- reactive({\n    kmeans(selectedData(), input$clusters)\n  })\n  \n  output$plot &lt;- renderPlot({\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n      \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n  \n    par(mar = c(4.1, 4.1, 0, 1))\n    magicaxis::magplot(selectedData(),\n         col = clusters()$cluster,\n         pch = 20, cex = 3, side=1:4,labels=c(T,T,F,F), \n         xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n         ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n    points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)"
  },
  {
    "objectID": "AstroInformatics.html",
    "href": "AstroInformatics.html",
    "title": "AstroInformatics",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "AstroInformatics.html#quarto",
    "href": "AstroInformatics.html#quarto",
    "title": "AstroInformatics",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "shift_fitting.html",
    "href": "shift_fitting.html",
    "title": "Shift-fitting under Heteroskedasticity",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\nlibrary(bslib)\n\n\n\nvars &lt;- setdiff(names(iris), \"Species\")\n\nui &lt;- page_sidebar(\n  sidebar = sidebar(open = \"open\", \nselectInput(\"model_type\", \"Model Type:\",\n            c(\"Linear\" = \"linear\", \n              \"Gaussian\" = \"gaussian\",\n              \"Poissonian\" = \"poissonian\",\n              \"Gamma\" = \"gamma\"),\n            selected='gaussian'),    \nselectInput(\"noise_model\", \"Noise Model:\",\n            c(\"Constant\" = \"constant\",\n            \"Linear\" = \"linear\",\n            \"Log-Linear\" = \"log-linear\"),\n            selected='log-linear'),\nselectInput(\"plot_type\", \"Figure Type:\",\n            c(\"Data & Model\" = \"data_model\",\n              \"Model Bias\" = \"bias\",\n              \"Bias-Width\" = \"correlation\"),\n            selected='data_model'),\ncheckboxInput(\"correct_htrsk\", \"Correct for Heteroskedasticity?\", FALSE),\nsliderInput(\"n.noise\",\n          \"Number of noise realisations per model (logarithmic):\",\n          min = 0,\n          max = 4,\n          step=0.01,\n          value = 2),\nsliderInput(\"noise_sd\",\n            withMathJax(\"Noise range (logarithmic) :\"),\n            min = -3, \n            max = 1,\n            step = 0.01, \n            value = c(-2,-1)),\nsliderInput(\"model_sd\",\n            withMathJax(\"Range of model param (slope/stdev)\"),\n            min = 0.1, \n            max = 1.9,\n            step = 0.01, \n            value = c(0.9,1.1)),\nsliderInput(\"nmodels\",\n            expression(\"Number of models to simulate\"),\n            min = 2,\n            max = 8,\n            step = 1, \n            value = 3),\nsliderInput(\"sample_range\",\n            expression(\"x-position sampling range\"),\n            min = -10,\n            max = 10,\n            step = 0.1, \n            value = c(-4,4)),\nsliderInput(\"num_samples\",\n            expression(\"Number of x-position samples (logarithmic)\"),\n            min = 0,\n            max = 4,\n            step = 0.1, \n            value = 2.0),\nsliderInput(\"annot_cex\",\n            expression(\"Annotation Scaling\"),\n            min = 0.5,\n            max = 2.5,\n            step = 0.1, \n            value = 1.5)\n  ),\n  plotOutput(\"plot\", height=\"100%\",width=\"100%\", fill=TRUE)\n)\n\nserver &lt;- function(input, output, session) {\n   selectedData &lt;- reactive({\n      iris[, c(input$xcol, input$ycol)]\n    })\n  \n  clusters &lt;- reactive({\n    kmeans(selectedData(), input$clusters)\n  })\n  \n  output$plot &lt;- renderPlot({\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n      \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n  \n    model&lt;-input$noise_model \n    min.noise.sd&lt;-10^(input$noise_sd[1])\n    max.noise.sd&lt;-10^(input$noise_sd[2])\n    #Define the grid of model widths\n    sds&lt;-seq(input$model_sd[1],input$model_sd[2],length=input$nmodels)\n    if (input$model_type=='gaussian') { \n      #Define the truth model N(0,1)\n      truth&lt;-function(x) dnorm(x,mean=0,sd=1)\n      #Define the fitted model dnorm N(mu,sig)\n      fitted&lt;-function(x,mean,width) dnorm(x,mean=mean,sd=width)\n    } else if (input$model_type=='linear') {\n      #Define the truth model y=x\n      truth&lt;-function(x) x\n      #Define the fitted model y=mx+b\n      fitted&lt;-function(x,intercept,slope) slope*x+intercept\n    } else { \n      stop(paste(\"model\",input$model_type,\"not yet implemented\")) \n    }\n    #Define the x sample points \n    x&lt;-seq(input$sample_range[1],input$sample_range[2],length=10^input$num_samples)\n    #Define the number of noise realisations\n    n.noise&lt;-10^input$n.noise\n\n  amp&lt;-fits&lt;-matrix(NA,nrow=length(sds),ncol=n.noise)\n  #Evaluate the truth at every x\n  y&lt;-truth(x)\n  #Generate the noise \n  if (model=='constant') { \n    noise.model&lt;-rep((min.noise.sd+max.noise.sd)/2,length(x))\n  } else if (model==\"linear\") { \n    noise.model&lt;-seq(min.noise.sd,max.noise.sd,len=length(x))\n  } else if (model==\"log-linear\") { \n    noise.model&lt;-10^seq(log10(min.noise.sd),log10(max.noise.sd),len=length(x))\n  } else { \n    stop(\"unknown noise model\") \n  }\n  #Loop through model widths\n  for (i in 1:length(sds)) {\n  #Loop through noise realisations \n    for (j in 1:n.noise) {\n  #Add noise to y data\n      yobs&lt;-y+rnorm(length(x),sd=noise.model)\n      if (input$model_type=='gaussian') { \n         #Fit the model for amplitude and centroid\n               tmp.fit&lt;-optim(par=list(mu=-1,A=1), \n                   fn=function(par) return=sum((yobs-\n                                                  par[2]*fitted(x,\n                                                                mean=par[1],\n                                                                width=sds[i])\n                                                )^2/noise.model))\n        #Save the best-fit parameters \n        fits[i,j]&lt;-tmp.fit$par[1]\n        amp[i,j]&lt;-tmp.fit$par[2]\n      } else if (input$model_type=='linear') { \n         #Fit the model for slope and intercept \n        tmp.fit&lt;-optim(par=list(intercept=1), \n                   fn=function(par) return=sum((yobs-\n                                                  fitted(x,\n                                                         slope=sds[i],\n                                                         intercept=par[1])\n                                                )^2/noise.model))\n        #Save the best-fit parameters \n        fits[i,j]&lt;-tmp.fit$par[1]\n      } \n      if (input$correct_htrsk) { \n        if (input$model_type=='gaussian') { \n          #Fit the model for amplitude and centroid with hetroskedasticity weights \n          resid&lt;-abs(yobs-amp[i,j]*fitted(x,fits[i,j],sds[i]))\n          resid_fit&lt;-lm(resid~obs,\n                        data=list(obs=fitted(x,mean=fits[i,j],width=sds[i]),\n                                  resid=resid))\n          resid_wgt&lt;-1/predict(resid_fit)^2\n          resid_wgt&lt;-resid_wgt/sum(resid_wgt)\n          tmp.fit&lt;-optim(par=list(mu=-1,A=1), \n              fn=function(par) return=sum((yobs-par[2]*fitted(x,mean=par[1],width=sds[i]))^2/noise.model*resid_wgt))\n          #Save the best-fit parameters \n          fits[i,j]&lt;-tmp.fit$par[1]\n          amp[i,j]&lt;-tmp.fit$par[2]\n        } else if (input$model_type=='linear') { \n          #Fit the model for amplitude and centroid with hetroskedasticity weights \n          resid&lt;-abs(yobs-fitted(x,fits[i,j],sds[i]))\n          resid_fit&lt;-lm(resid~obs,\n                        data=list(obs=fitted(x,intercept=fits[i,j],slope=sds[i]),\n                                  resid=resid))\n          resid_wgt&lt;-1/predict(resid_fit)^2\n          resid_wgt&lt;-resid_wgt/sum(resid_wgt)\n          tmp.fit&lt;-optim(par=list(intercept=-1), \n              fn=function(par) return=sum((yobs-\n                                             fitted(x,\n                                                    intercept=par[1],\n                                                    width=sds[i])\n                                           )^2/noise.model*resid_wgt))\n          #Save the best-fit parameters \n          fits[i,j]&lt;-tmp.fit$par[1]\n        }\n      }\n    }\n  }\n  #Initialise the plot\n  par(mar = c(4.1, 4.1, 0, 1))\n  if (input$plot_type=='data_model') { \n    if (input$model_type=='linear') { \n      magicaxis::magplot(x,yobs,pch=20,xlab='x',ylab='f(x)',ylim=range(x),\n              cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    } else { \n      magicaxis::magplot(x,yobs,pch=20,xlab='x',ylab='n(x)',ylim=c(-0.05,0.5),\n              cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    } \n    #Loop over model widths \n    for (i in 1:length(sds)) {\n      #Plot 100 of the best-fit models \n      for (j in sample(x=1:n.noise,size=100)) { \n        if (input$model_type=='gaussian') { \n          lines(x,amp[i,j]*dnorm(x,mean=fits[i,j],sd=sds[i]),\n                col=seqinr::col2alpha(RColorBrewer::brewer.pal(8,'Set2')[i],alpha=0.1),lwd=2)\n        } else if (input$model_type=='linear') { \n          lines(x,sds[i]*x+fits[i,j],\n                col=seqinr::col2alpha(RColorBrewer::brewer.pal(8,'Set2')[i],alpha=0.1),lwd=2)\n        }\n      }\n    }\n    #Add one noise realisation of the data\n    points(x,yobs,pch=20)\n    #Add the uncertanties\n    magicaxis::magerr(x,yobs,ylo=noise.model)\n    #Add the legend\n    if (input$model_type=='linear') labbase&lt;-'INT:'\n    if (input$model_type=='gaussian') labbase&lt;-'STD:'\n    legend('topleft',lty=1,lwd=2,col=c('black',RColorBrewer::brewer.pal(8,'Set2')),\n      legend=c(paste0(labbase,' 1.0'),paste(labbase,round(digits=2,sds[1:floor(length(sds)/2)]))),\n      bty='n',pch=c(20,NA,NA),\n      cex=input$annot_cex,inset=0.02)\n    legend('topright',lty=1,lwd=2,\n           col=c(RColorBrewer::brewer.pal(8,'Set2')[-(1:floor(length(sds)/2))]),\n      legend=paste(labbase,round(digits=2,sds[-(1:floor(length(sds)/2))])),\n                   bty='n',cex=input$annot_cex,inset=0.02)\n    #Add the noise model\n    #tcoord&lt;-helpRfuncs::text.coord(loc='left',inset=0.15)\n    tcoord&lt;-c(quantile(x,prob=0.20),0.25)\n    text(tcoord[1],tcoord[2],lab=paste0('Noise Model:\\n',model),pos=3,cex=input$annot_cex) \n  } else if (input$plot_type=='bias') { \n    #Initialise the best-fit means plot\n    magicaxis::magplot(density(fits[1,],bw=0.01/sqrt(12),kern='rect',\n                    from=min(c(-0.2,min(fits))),\n                    to=max(c(0.2,max(fits)))),\n            xlab='Model Bias',ylab='PDF',type='n',\n            cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    #Loop over each of the model widths\n    for (i in 1:length(sds)) {\n      lines(density(fits[i,],bw=0.05/sqrt(12),kern='rect',\n                    from=-2*max(abs(sds-1)),\n                    to=2*max(abs(sds-1))),\n            col=RColorBrewer::brewer.pal(8,'Set2')[i],lwd=2)\n    }\n  } else if (input$plot_type=='correlation') { \n    #Initialise the best-fit means plot\n    if (input$model_type=='linear') labbase&lt;-'Intercept'\n    if (input$model_type=='gaussian') labbase&lt;-'Stdev'\n    magicaxis::magplot(jitter(rep(sds,n.noise)),fits,\n            col=rep(RColorBrewer::brewer.pal(8,'Set2')[1:length(sds)],n.noise),\n            ylab='Model Bias',xlab=paste('Model',labbase),type='p',pch=20,\n            cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    dat&lt;-data.frame(sds=rep(sds,n.noise),fits=as.numeric(fits))\n    new&lt;-data.frame(sds=seq(min(sds)-1,max(sds)+1,len=1e3))\n    lm.fit&lt;-lm(fits~sds,dat)\n    matplot(new$sds,\n          cbind(predict(lm.fit,newdata=new,interval='confidence'),\n                predict(lm.fit,newdata=new,interval='prediction')[,-1]),\n          lwd=c(2,1,1,1,1),lty=c(1,2,2,3,3),col='black',type='l',add=TRUE)\n  }\n\n    #magicaxis::magplot(selectedData(),\n    #     col = clusters()$cluster,\n    #     pch = 20, cex = 3, side=1:4,labels=c(T,T,F,F), \n    #     xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n    #     ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n    #points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  #} else { \n  #  par(mar = c(4.1, 4.1, 0, 1))\n  #  magicaxis::magplot(selectedData(),\n  #       col = clusters()$cluster,\n  #       pch = 15, cex = 3, side=1:4,labels=c(T,T,F,F), \n  #       xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n  #       ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n  #  points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  #}\n  })\n}\n\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)"
  }
]