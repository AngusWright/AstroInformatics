{"title":"Our first r-shinylive Quarto document!","markdown":{"yaml":{"title":"Shift-fitting under Heteroskedasticity","filters":["shinylive"],"format":{"html":{"cache":true}}},"headingText":"Create Shiny app ----","containsRefs":false,"markdown":"\n\n<!---\nrevealjs: \n    scrollable: true \n    fig-width: 400\n    fig-height: 400\n    fig-responsive: true\n    fig-dpi: 220\n---> \n\n\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\nlibrary(bslib)\n\n\n\nvars <- setdiff(names(iris), \"Species\")\n\nui <- page_sidebar(\n  sidebar = sidebar(open = \"open\", \nselectInput(\"model_type\", \"Model Type:\",\n            c(\"Linear\" = \"linear\", \n              \"Gaussian\" = \"gaussian\",\n              \"Poissonian\" = \"poissonian\",\n              \"Gamma\" = \"gamma\"),\n            selected='gaussian'),    \nselectInput(\"noise_model\", \"Noise Model:\",\n            c(\"Constant\" = \"constant\",\n            \"Linear\" = \"linear\",\n            \"Log-Linear\" = \"log-linear\"),\n            selected='log-linear'),\nselectInput(\"plot_type\", \"Figure Type:\",\n            c(\"Data & Model\" = \"data_model\",\n              \"Model Bias\" = \"bias\",\n              \"Bias-Width\" = \"correlation\"),\n            selected='data_model'),\ncheckboxInput(\"correct_htrsk\", \"Correct for Heteroskedasticity?\", FALSE),\nsliderInput(\"n.noise\",\n          \"Number of noise realisations per model (logarithmic):\",\n          min = 0,\n          max = 4,\n          step=0.01,\n          value = 2),\nsliderInput(\"noise_sd\",\n            withMathJax(\"Noise range (logarithmic) :\"),\n            min = -3, \n            max = 1,\n            step = 0.01, \n            value = c(-2,-1)),\nsliderInput(\"model_sd\",\n            withMathJax(\"Range of model param (slope/stdev)\"),\n            min = 0.1, \n            max = 1.9,\n            step = 0.01, \n            value = c(0.9,1.1)),\nsliderInput(\"nmodels\",\n            expression(\"Number of models to simulate\"),\n            min = 2,\n            max = 8,\n            step = 1, \n            value = 3),\nsliderInput(\"sample_range\",\n            expression(\"x-position sampling range\"),\n            min = -10,\n            max = 10,\n            step = 0.1, \n            value = c(-4,4)),\nsliderInput(\"num_samples\",\n            expression(\"Number of x-position samples (logarithmic)\"),\n            min = 0,\n            max = 4,\n            step = 0.1, \n            value = 2.0),\nsliderInput(\"annot_cex\",\n            expression(\"Annotation Scaling\"),\n            min = 0.5,\n            max = 2.5,\n            step = 0.1, \n            value = 1.5)\n  ),\n  plotOutput(\"plot\", height=\"100%\",width=\"100%\", fill=TRUE)\n)\n\nserver <- function(input, output, session) {\n   selectedData <- reactive({\n      iris[, c(input$xcol, input$ycol)]\n    })\n  \n  clusters <- reactive({\n    kmeans(selectedData(), input$clusters)\n  })\n  \n  output$plot <- renderPlot({\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n      \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n  \n    model<-input$noise_model \n    min.noise.sd<-10^(input$noise_sd[1])\n    max.noise.sd<-10^(input$noise_sd[2])\n    #Define the grid of model widths\n    sds<-seq(input$model_sd[1],input$model_sd[2],length=input$nmodels)\n    if (input$model_type=='gaussian') { \n      #Define the truth model N(0,1)\n      truth<-function(x) dnorm(x,mean=0,sd=1)\n      #Define the fitted model dnorm N(mu,sig)\n      fitted<-function(x,mean,width) dnorm(x,mean=mean,sd=width)\n    } else if (input$model_type=='linear') {\n      #Define the truth model y=x\n      truth<-function(x) x\n      #Define the fitted model y=mx+b\n      fitted<-function(x,intercept,slope) slope*x+intercept\n    } else { \n      stop(paste(\"model\",input$model_type,\"not yet implemented\")) \n    }\n    #Define the x sample points \n    x<-seq(input$sample_range[1],input$sample_range[2],length=10^input$num_samples)\n    #Define the number of noise realisations\n    n.noise<-10^input$n.noise\n\n  amp<-fits<-matrix(NA,nrow=length(sds),ncol=n.noise)\n  #Evaluate the truth at every x\n  y<-truth(x)\n  #Generate the noise \n  if (model=='constant') { \n    noise.model<-rep((min.noise.sd+max.noise.sd)/2,length(x))\n  } else if (model==\"linear\") { \n    noise.model<-seq(min.noise.sd,max.noise.sd,len=length(x))\n  } else if (model==\"log-linear\") { \n    noise.model<-10^seq(log10(min.noise.sd),log10(max.noise.sd),len=length(x))\n  } else { \n    stop(\"unknown noise model\") \n  }\n  #Loop through model widths\n  for (i in 1:length(sds)) {\n  #Loop through noise realisations \n    for (j in 1:n.noise) {\n  #Add noise to y data\n      yobs<-y+rnorm(length(x),sd=noise.model)\n      if (input$model_type=='gaussian') { \n         #Fit the model for amplitude and centroid\n               tmp.fit<-optim(par=list(mu=-1,A=1), \n                   fn=function(par) return=sum((yobs-\n                                                  par[2]*fitted(x,\n                                                                mean=par[1],\n                                                                width=sds[i])\n                                                )^2/noise.model))\n        #Save the best-fit parameters \n        fits[i,j]<-tmp.fit$par[1]\n        amp[i,j]<-tmp.fit$par[2]\n      } else if (input$model_type=='linear') { \n         #Fit the model for slope and intercept \n        tmp.fit<-optim(par=list(intercept=1), \n                   fn=function(par) return=sum((yobs-\n                                                  fitted(x,\n                                                         slope=sds[i],\n                                                         intercept=par[1])\n                                                )^2/noise.model))\n        #Save the best-fit parameters \n        fits[i,j]<-tmp.fit$par[1]\n      } \n      if (input$correct_htrsk) { \n        if (input$model_type=='gaussian') { \n          #Fit the model for amplitude and centroid with hetroskedasticity weights \n          resid<-abs(yobs-amp[i,j]*fitted(x,fits[i,j],sds[i]))\n          resid_fit<-lm(resid~obs,\n                        data=list(obs=fitted(x,mean=fits[i,j],width=sds[i]),\n                                  resid=resid))\n          resid_wgt<-1/predict(resid_fit)^2\n          resid_wgt<-resid_wgt/sum(resid_wgt)\n          tmp.fit<-optim(par=list(mu=-1,A=1), \n              fn=function(par) return=sum((yobs-par[2]*fitted(x,mean=par[1],width=sds[i]))^2/noise.model*resid_wgt))\n          #Save the best-fit parameters \n          fits[i,j]<-tmp.fit$par[1]\n          amp[i,j]<-tmp.fit$par[2]\n        } else if (input$model_type=='linear') { \n          #Fit the model for amplitude and centroid with hetroskedasticity weights \n          resid<-abs(yobs-fitted(x,fits[i,j],sds[i]))\n          resid_fit<-lm(resid~obs,\n                        data=list(obs=fitted(x,intercept=fits[i,j],slope=sds[i]),\n                                  resid=resid))\n          resid_wgt<-1/predict(resid_fit)^2\n          resid_wgt<-resid_wgt/sum(resid_wgt)\n          tmp.fit<-optim(par=list(intercept=-1), \n              fn=function(par) return=sum((yobs-\n                                             fitted(x,\n                                                    intercept=par[1],\n                                                    width=sds[i])\n                                           )^2/noise.model*resid_wgt))\n          #Save the best-fit parameters \n          fits[i,j]<-tmp.fit$par[1]\n        }\n      }\n    }\n  }\n  #Initialise the plot\n  par(mar = c(4.1, 4.1, 0, 1))\n  if (input$plot_type=='data_model') { \n    if (input$model_type=='linear') { \n      magicaxis::magplot(x,yobs,pch=20,xlab='x',ylab='f(x)',ylim=range(x),\n              cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    } else { \n      magicaxis::magplot(x,yobs,pch=20,xlab='x',ylab='n(x)',ylim=c(-0.05,0.5),\n              cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    } \n    #Loop over model widths \n    for (i in 1:length(sds)) {\n      #Plot 100 of the best-fit models \n      for (j in sample(x=1:n.noise,size=100)) { \n        if (input$model_type=='gaussian') { \n          lines(x,amp[i,j]*dnorm(x,mean=fits[i,j],sd=sds[i]),\n                col=seqinr::col2alpha(RColorBrewer::brewer.pal(8,'Set2')[i],alpha=0.1),lwd=2)\n        } else if (input$model_type=='linear') { \n          lines(x,sds[i]*x+fits[i,j],\n                col=seqinr::col2alpha(RColorBrewer::brewer.pal(8,'Set2')[i],alpha=0.1),lwd=2)\n        }\n      }\n    }\n    #Add one noise realisation of the data\n    points(x,yobs,pch=20)\n    #Add the uncertanties\n    magicaxis::magerr(x,yobs,ylo=noise.model)\n    #Add the legend\n    if (input$model_type=='linear') labbase<-'INT:'\n    if (input$model_type=='gaussian') labbase<-'STD:'\n    legend('topleft',lty=1,lwd=2,col=c('black',RColorBrewer::brewer.pal(8,'Set2')),\n      legend=c(paste0(labbase,' 1.0'),paste(labbase,round(digits=2,sds[1:floor(length(sds)/2)]))),\n      bty='n',pch=c(20,NA,NA),\n      cex=input$annot_cex,inset=0.02)\n    legend('topright',lty=1,lwd=2,\n           col=c(RColorBrewer::brewer.pal(8,'Set2')[-(1:floor(length(sds)/2))]),\n      legend=paste(labbase,round(digits=2,sds[-(1:floor(length(sds)/2))])),\n                   bty='n',cex=input$annot_cex,inset=0.02)\n    #Add the noise model\n    #tcoord<-helpRfuncs::text.coord(loc='left',inset=0.15)\n    tcoord<-c(quantile(x,prob=0.20),0.25)\n    text(tcoord[1],tcoord[2],lab=paste0('Noise Model:\\n',model),pos=3,cex=input$annot_cex) \n  } else if (input$plot_type=='bias') { \n    #Initialise the best-fit means plot\n    magicaxis::magplot(density(fits[1,],bw=0.01/sqrt(12),kern='rect',\n                    from=min(c(-0.2,min(fits))),\n                    to=max(c(0.2,max(fits)))),\n            xlab='Model Bias',ylab='PDF',type='n',\n            cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    #Loop over each of the model widths\n    for (i in 1:length(sds)) {\n      lines(density(fits[i,],bw=0.05/sqrt(12),kern='rect',\n                    from=-2*max(abs(sds-1)),\n                    to=2*max(abs(sds-1))),\n            col=RColorBrewer::brewer.pal(8,'Set2')[i],lwd=2)\n    }\n  } else if (input$plot_type=='correlation') { \n    #Initialise the best-fit means plot\n    if (input$model_type=='linear') labbase<-'Intercept'\n    if (input$model_type=='gaussian') labbase<-'Stdev'\n    magicaxis::magplot(jitter(rep(sds,n.noise)),fits,\n            col=rep(RColorBrewer::brewer.pal(8,'Set2')[1:length(sds)],n.noise),\n            ylab='Model Bias',xlab=paste('Model',labbase),type='p',pch=20,\n            cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    dat<-data.frame(sds=rep(sds,n.noise),fits=as.numeric(fits))\n    new<-data.frame(sds=seq(min(sds)-1,max(sds)+1,len=1e3))\n    lm.fit<-lm(fits~sds,dat)\n    matplot(new$sds,\n          cbind(predict(lm.fit,newdata=new,interval='confidence'),\n                predict(lm.fit,newdata=new,interval='prediction')[,-1]),\n          lwd=c(2,1,1,1,1),lty=c(1,2,2,3,3),col='black',type='l',add=TRUE)\n  }\n\n    #magicaxis::magplot(selectedData(),\n    #     col = clusters()$cluster,\n    #     pch = 20, cex = 3, side=1:4,labels=c(T,T,F,F), \n    #     xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n    #     ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n    #points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  #} else { \n  #  par(mar = c(4.1, 4.1, 0, 1))\n  #  magicaxis::magplot(selectedData(),\n  #       col = clusters()$cluster,\n  #       pch = 15, cex = 3, side=1:4,labels=c(T,T,F,F), \n  #       xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n  #       ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n  #  points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  #}\n  })\n}\n\n\nshinyApp(ui = ui, server = server)\n\n```\n\n","srcMarkdownNoYaml":"\n\n<!---\nrevealjs: \n    scrollable: true \n    fig-width: 400\n    fig-height: 400\n    fig-responsive: true\n    fig-dpi: 220\n---> \n\n\n\n\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 600\n\nlibrary(shiny)\nlibrary(bslib)\n\n\n\nvars <- setdiff(names(iris), \"Species\")\n\nui <- page_sidebar(\n  sidebar = sidebar(open = \"open\", \nselectInput(\"model_type\", \"Model Type:\",\n            c(\"Linear\" = \"linear\", \n              \"Gaussian\" = \"gaussian\",\n              \"Poissonian\" = \"poissonian\",\n              \"Gamma\" = \"gamma\"),\n            selected='gaussian'),    \nselectInput(\"noise_model\", \"Noise Model:\",\n            c(\"Constant\" = \"constant\",\n            \"Linear\" = \"linear\",\n            \"Log-Linear\" = \"log-linear\"),\n            selected='log-linear'),\nselectInput(\"plot_type\", \"Figure Type:\",\n            c(\"Data & Model\" = \"data_model\",\n              \"Model Bias\" = \"bias\",\n              \"Bias-Width\" = \"correlation\"),\n            selected='data_model'),\ncheckboxInput(\"correct_htrsk\", \"Correct for Heteroskedasticity?\", FALSE),\nsliderInput(\"n.noise\",\n          \"Number of noise realisations per model (logarithmic):\",\n          min = 0,\n          max = 4,\n          step=0.01,\n          value = 2),\nsliderInput(\"noise_sd\",\n            withMathJax(\"Noise range (logarithmic) :\"),\n            min = -3, \n            max = 1,\n            step = 0.01, \n            value = c(-2,-1)),\nsliderInput(\"model_sd\",\n            withMathJax(\"Range of model param (slope/stdev)\"),\n            min = 0.1, \n            max = 1.9,\n            step = 0.01, \n            value = c(0.9,1.1)),\nsliderInput(\"nmodels\",\n            expression(\"Number of models to simulate\"),\n            min = 2,\n            max = 8,\n            step = 1, \n            value = 3),\nsliderInput(\"sample_range\",\n            expression(\"x-position sampling range\"),\n            min = -10,\n            max = 10,\n            step = 0.1, \n            value = c(-4,4)),\nsliderInput(\"num_samples\",\n            expression(\"Number of x-position samples (logarithmic)\"),\n            min = 0,\n            max = 4,\n            step = 0.1, \n            value = 2.0),\nsliderInput(\"annot_cex\",\n            expression(\"Annotation Scaling\"),\n            min = 0.5,\n            max = 2.5,\n            step = 0.1, \n            value = 1.5)\n  ),\n  plotOutput(\"plot\", height=\"100%\",width=\"100%\", fill=TRUE)\n)\n\nserver <- function(input, output, session) {\n   selectedData <- reactive({\n      iris[, c(input$xcol, input$ycol)]\n    })\n  \n  clusters <- reactive({\n    kmeans(selectedData(), input$clusters)\n  })\n  \n  output$plot <- renderPlot({\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n      \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n  \n    model<-input$noise_model \n    min.noise.sd<-10^(input$noise_sd[1])\n    max.noise.sd<-10^(input$noise_sd[2])\n    #Define the grid of model widths\n    sds<-seq(input$model_sd[1],input$model_sd[2],length=input$nmodels)\n    if (input$model_type=='gaussian') { \n      #Define the truth model N(0,1)\n      truth<-function(x) dnorm(x,mean=0,sd=1)\n      #Define the fitted model dnorm N(mu,sig)\n      fitted<-function(x,mean,width) dnorm(x,mean=mean,sd=width)\n    } else if (input$model_type=='linear') {\n      #Define the truth model y=x\n      truth<-function(x) x\n      #Define the fitted model y=mx+b\n      fitted<-function(x,intercept,slope) slope*x+intercept\n    } else { \n      stop(paste(\"model\",input$model_type,\"not yet implemented\")) \n    }\n    #Define the x sample points \n    x<-seq(input$sample_range[1],input$sample_range[2],length=10^input$num_samples)\n    #Define the number of noise realisations\n    n.noise<-10^input$n.noise\n\n  amp<-fits<-matrix(NA,nrow=length(sds),ncol=n.noise)\n  #Evaluate the truth at every x\n  y<-truth(x)\n  #Generate the noise \n  if (model=='constant') { \n    noise.model<-rep((min.noise.sd+max.noise.sd)/2,length(x))\n  } else if (model==\"linear\") { \n    noise.model<-seq(min.noise.sd,max.noise.sd,len=length(x))\n  } else if (model==\"log-linear\") { \n    noise.model<-10^seq(log10(min.noise.sd),log10(max.noise.sd),len=length(x))\n  } else { \n    stop(\"unknown noise model\") \n  }\n  #Loop through model widths\n  for (i in 1:length(sds)) {\n  #Loop through noise realisations \n    for (j in 1:n.noise) {\n  #Add noise to y data\n      yobs<-y+rnorm(length(x),sd=noise.model)\n      if (input$model_type=='gaussian') { \n         #Fit the model for amplitude and centroid\n               tmp.fit<-optim(par=list(mu=-1,A=1), \n                   fn=function(par) return=sum((yobs-\n                                                  par[2]*fitted(x,\n                                                                mean=par[1],\n                                                                width=sds[i])\n                                                )^2/noise.model))\n        #Save the best-fit parameters \n        fits[i,j]<-tmp.fit$par[1]\n        amp[i,j]<-tmp.fit$par[2]\n      } else if (input$model_type=='linear') { \n         #Fit the model for slope and intercept \n        tmp.fit<-optim(par=list(intercept=1), \n                   fn=function(par) return=sum((yobs-\n                                                  fitted(x,\n                                                         slope=sds[i],\n                                                         intercept=par[1])\n                                                )^2/noise.model))\n        #Save the best-fit parameters \n        fits[i,j]<-tmp.fit$par[1]\n      } \n      if (input$correct_htrsk) { \n        if (input$model_type=='gaussian') { \n          #Fit the model for amplitude and centroid with hetroskedasticity weights \n          resid<-abs(yobs-amp[i,j]*fitted(x,fits[i,j],sds[i]))\n          resid_fit<-lm(resid~obs,\n                        data=list(obs=fitted(x,mean=fits[i,j],width=sds[i]),\n                                  resid=resid))\n          resid_wgt<-1/predict(resid_fit)^2\n          resid_wgt<-resid_wgt/sum(resid_wgt)\n          tmp.fit<-optim(par=list(mu=-1,A=1), \n              fn=function(par) return=sum((yobs-par[2]*fitted(x,mean=par[1],width=sds[i]))^2/noise.model*resid_wgt))\n          #Save the best-fit parameters \n          fits[i,j]<-tmp.fit$par[1]\n          amp[i,j]<-tmp.fit$par[2]\n        } else if (input$model_type=='linear') { \n          #Fit the model for amplitude and centroid with hetroskedasticity weights \n          resid<-abs(yobs-fitted(x,fits[i,j],sds[i]))\n          resid_fit<-lm(resid~obs,\n                        data=list(obs=fitted(x,intercept=fits[i,j],slope=sds[i]),\n                                  resid=resid))\n          resid_wgt<-1/predict(resid_fit)^2\n          resid_wgt<-resid_wgt/sum(resid_wgt)\n          tmp.fit<-optim(par=list(intercept=-1), \n              fn=function(par) return=sum((yobs-\n                                             fitted(x,\n                                                    intercept=par[1],\n                                                    width=sds[i])\n                                           )^2/noise.model*resid_wgt))\n          #Save the best-fit parameters \n          fits[i,j]<-tmp.fit$par[1]\n        }\n      }\n    }\n  }\n  #Initialise the plot\n  par(mar = c(4.1, 4.1, 0, 1))\n  if (input$plot_type=='data_model') { \n    if (input$model_type=='linear') { \n      magicaxis::magplot(x,yobs,pch=20,xlab='x',ylab='f(x)',ylim=range(x),\n              cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    } else { \n      magicaxis::magplot(x,yobs,pch=20,xlab='x',ylab='n(x)',ylim=c(-0.05,0.5),\n              cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    } \n    #Loop over model widths \n    for (i in 1:length(sds)) {\n      #Plot 100 of the best-fit models \n      for (j in sample(x=1:n.noise,size=100)) { \n        if (input$model_type=='gaussian') { \n          lines(x,amp[i,j]*dnorm(x,mean=fits[i,j],sd=sds[i]),\n                col=seqinr::col2alpha(RColorBrewer::brewer.pal(8,'Set2')[i],alpha=0.1),lwd=2)\n        } else if (input$model_type=='linear') { \n          lines(x,sds[i]*x+fits[i,j],\n                col=seqinr::col2alpha(RColorBrewer::brewer.pal(8,'Set2')[i],alpha=0.1),lwd=2)\n        }\n      }\n    }\n    #Add one noise realisation of the data\n    points(x,yobs,pch=20)\n    #Add the uncertanties\n    magicaxis::magerr(x,yobs,ylo=noise.model)\n    #Add the legend\n    if (input$model_type=='linear') labbase<-'INT:'\n    if (input$model_type=='gaussian') labbase<-'STD:'\n    legend('topleft',lty=1,lwd=2,col=c('black',RColorBrewer::brewer.pal(8,'Set2')),\n      legend=c(paste0(labbase,' 1.0'),paste(labbase,round(digits=2,sds[1:floor(length(sds)/2)]))),\n      bty='n',pch=c(20,NA,NA),\n      cex=input$annot_cex,inset=0.02)\n    legend('topright',lty=1,lwd=2,\n           col=c(RColorBrewer::brewer.pal(8,'Set2')[-(1:floor(length(sds)/2))]),\n      legend=paste(labbase,round(digits=2,sds[-(1:floor(length(sds)/2))])),\n                   bty='n',cex=input$annot_cex,inset=0.02)\n    #Add the noise model\n    #tcoord<-helpRfuncs::text.coord(loc='left',inset=0.15)\n    tcoord<-c(quantile(x,prob=0.20),0.25)\n    text(tcoord[1],tcoord[2],lab=paste0('Noise Model:\\n',model),pos=3,cex=input$annot_cex) \n  } else if (input$plot_type=='bias') { \n    #Initialise the best-fit means plot\n    magicaxis::magplot(density(fits[1,],bw=0.01/sqrt(12),kern='rect',\n                    from=min(c(-0.2,min(fits))),\n                    to=max(c(0.2,max(fits)))),\n            xlab='Model Bias',ylab='PDF',type='n',\n            cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    #Loop over each of the model widths\n    for (i in 1:length(sds)) {\n      lines(density(fits[i,],bw=0.05/sqrt(12),kern='rect',\n                    from=-2*max(abs(sds-1)),\n                    to=2*max(abs(sds-1))),\n            col=RColorBrewer::brewer.pal(8,'Set2')[i],lwd=2)\n    }\n  } else if (input$plot_type=='correlation') { \n    #Initialise the best-fit means plot\n    if (input$model_type=='linear') labbase<-'Intercept'\n    if (input$model_type=='gaussian') labbase<-'Stdev'\n    magicaxis::magplot(jitter(rep(sds,n.noise)),fits,\n            col=rep(RColorBrewer::brewer.pal(8,'Set2')[1:length(sds)],n.noise),\n            ylab='Model Bias',xlab=paste('Model',labbase),type='p',pch=20,\n            cex.lab=input$annot_cex,cex.axis=input$annot_cex)\n    dat<-data.frame(sds=rep(sds,n.noise),fits=as.numeric(fits))\n    new<-data.frame(sds=seq(min(sds)-1,max(sds)+1,len=1e3))\n    lm.fit<-lm(fits~sds,dat)\n    matplot(new$sds,\n          cbind(predict(lm.fit,newdata=new,interval='confidence'),\n                predict(lm.fit,newdata=new,interval='prediction')[,-1]),\n          lwd=c(2,1,1,1,1),lty=c(1,2,2,3,3),col='black',type='l',add=TRUE)\n  }\n\n    #magicaxis::magplot(selectedData(),\n    #     col = clusters()$cluster,\n    #     pch = 20, cex = 3, side=1:4,labels=c(T,T,F,F), \n    #     xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n    #     ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n    #points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  #} else { \n  #  par(mar = c(4.1, 4.1, 0, 1))\n  #  magicaxis::magplot(selectedData(),\n  #       col = clusters()$cluster,\n  #       pch = 15, cex = 3, side=1:4,labels=c(T,T,F,F), \n  #       xlab=\"xlabel\", #gsub(\"\\.\",\" \",input$xcol),\n  #       ylab=\"ylabel\") #gsub(\"\\.\",\" \",input$ycol))\n  #  points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n  #}\n  })\n}\n\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["shinylive"],"output-file":"first_shinylive.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","title":"Our first r-shinylive Quarto document!"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}